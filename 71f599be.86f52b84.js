(window.webpackJsonp=window.webpackJsonp||[]).push([[584],{1441:function(e,t,n){"use strict";n.d(t,"a",(function(){return c})),n.d(t,"b",(function(){return O}));var l=n(0),o=n.n(l);function b(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);t&&(l=l.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,l)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){b(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function u(e,t){if(null==e)return{};var n,l,o=function(e,t){if(null==e)return{};var n,l,o={},b=Object.keys(e);for(l=0;l<b.length;l++)n=b[l],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var b=Object.getOwnPropertySymbols(e);for(l=0;l<b.length;l++)n=b[l],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var p=o.a.createContext({}),a=function(e){var t=o.a.useContext(p),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=a(e.components);return o.a.createElement(p.Provider,{value:t},e.children)},s={inlineCode:"code",wrapper:function(e){var t=e.children;return o.a.createElement(o.a.Fragment,{},t)}},d=o.a.forwardRef((function(e,t){var n=e.components,l=e.mdxType,b=e.originalType,r=e.parentName,p=u(e,["components","mdxType","originalType","parentName"]),c=a(n),d=l,O=c["".concat(r,".").concat(d)]||c[d]||s[d]||b;return n?o.a.createElement(O,i(i({ref:t},p),{},{components:n})):o.a.createElement(O,i({ref:t},p))}));function O(e,t){var n=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var b=n.length,r=new Array(b);r[0]=d;var i={};for(var u in t)hasOwnProperty.call(t,u)&&(i[u]=t[u]);i.originalType=e,i.mdxType="string"==typeof e?e:l,r[1]=i;for(var p=2;p<b;p++)r[p]=n[p];return o.a.createElement.apply(null,r)}return o.a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},663:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return r})),n.d(t,"metadata",(function(){return i})),n.d(t,"toc",(function(){return u})),n.d(t,"default",(function(){return a}));var l=n(3),o=n(7),b=(n(0),n(1441)),r={id:"CreateAnsysJob",title:"CreateAnsysJob",author:"TechnoStar Co., Ltd.",authorURL:"https://www.e-technostar.com/"},i={unversionedId:"macro/analysis/CreateAnsysJob",id:"macro/analysis/CreateAnsysJob",isDocsHomePage:!1,title:"CreateAnsysJob",description:"Description",source:"@site/docs\\macro\\analysis\\Macro-Analysis-CreateAnsysJob.md",slug:"/macro/analysis/CreateAnsysJob",permalink:"/testweb/docs/macro/analysis/CreateAnsysJob",version:"current",sidebar:"api",previous:{title:"AdvcModalFreqRespProcess",permalink:"/testweb/docs/macro/analysis/AdvcModalFreqRespProcess"},next:{title:"NastranJob",permalink:"/testweb/docs/macro/analysis/NastranJob"}},u=[{value:"Description",id:"description",children:[]},{value:"Syntax",id:"syntax",children:[]},{value:"Inputs",id:"inputs",children:[]},{value:"Return Code",id:"return-code",children:[]},{value:"Sample Code",id:"sample-code",children:[]}],p={toc:u};function a(e){var t=e.components,n=Object(o.a)(e,["components"]);return Object(b.b)("wrapper",Object(l.a)({},p,n,{components:t,mdxType:"MDXLayout"}),Object(b.b)("h2",{id:"description"},"Description"),Object(b.b)("p",null,"Create Ansys Job"),Object(b.b)("h2",{id:"syntax"},"Syntax"),Object(b.b)("p",null,"CreateAnsysJob(Cstring name, int analysisType, int SolverType, Cstirng JobName, Cstring JobDescription, bool bOutputDisplacements, bool bOutputReactionLoad, bool bOutputStrain, bool bOutputStress, int iAnalysisOpt, bool bCal_Press_effects, double fUniTem, double fRefTemp, double fEndLoadtime, int iTimeStep, int iStepChosen, int iSubStepNum, int iMaxSubStep, int iMinStepNum, double fTimeStepSize, double fMinTimeStep, double fMaxTimeStep, int iWriteReslutFre, int iN, bool bRunAPDL, bool bWriteResultDB, double fEndFreq, double fStartFreq, int iSolutionOption, double fPropChange, int iPointNum, double fMinTemp, double fMaxTemp, int EquationSolv, double fTolLevel, double fMultiplier, bool bSignlePrecision, double fTempDiff, double fStartFreq, double fEndFreq, int nSubsteps, double fAlphad, double fBetad, double fDmprat, bool bOutputDisplacements, bool bOutputStrain, bool bOutputStress, int iLCId, int imodeShape, int iModeMethod, int iExtractNum, bool bExpandShape, int iExpandNum, bool bUseApprox, bool bInclPrssEff, bool bMemorySave, bool bRsvec, bool bOutputDisplacements, bool bOutputStrain, bool bOutputStress, int iPrintNum, bool bMemorySave, bool bOutputHeatFlux, bool bOutputTemperature, bool bPivotsCheck, bool bSignlePrecision, double fMultiplier, double fTempDiff, double fTolLevel, int iAdaptiveDes, int iEquationSolv, int iNPOption, Cstring AnsysVersion, Cstring CommandLineOption, bool OutputSOLVE, int iRigidMode, int iWorkSize, int iNPADNum, int iBlockNum, int iMaxiteratCnt, int iMinNShift, int iSeqCheck, bool bTranEffect, int iLoadingType, double fMassMatrixMult, double fStiffMatrixMult, bool bMidStep, double fToleranceBisection, double fToleranceTimeStep, int iTimeInterAlgor, int iTimeInter, double fGAMMA, double fALPHA, double fDELTA, double fALPHAF, double fALPHAM, bool bOutputTemperature, bool bOutputHeatFlux, Cursor Edit)"),Object(b.b)("h2",{id:"inputs"},"Inputs"),Object(b.b)("p",null,"1",".","  Cstring\nName Job"),Object(b.b)("p",null,"2",".","  int\nAnalysis Type","[0:none 1:struct 2:thermal]"),Object(b.b)("p",null,"3",".","  int\nSolver Type ","[0:none 1:modal 2:hamonic 3:static 4:struct transient 5:steady state 6:thermal transient]"),Object(b.b)("p",null,"4",".","  Cstring\nName Job"),Object(b.b)("p",null,"5",".","  Cstring\nJob description"),Object(b.b)("p",null,"6",".","  bool\nOutput Displacements"),Object(b.b)("p",null,"7",".","  bool\nOutput Reaction Load"),Object(b.b)("p",null,"8",".","  bool\nOutput Strain"),Object(b.b)("p",null,"9",".","  bool\nOutput Stress"),Object(b.b)("p",null,"10",".","  int\nAnalysis Opt ","[0 = small displacement,1 = large displacement ]"),Object(b.b)("p",null,"11",".","  bool\nCal Press effects"),Object(b.b)("p",null,"12",".","  double\nUniform temperature"),Object(b.b)("p",null,"13",".","  double\nReference temperature"),Object(b.b)("p",null,"14",".","  double\nEnd load time"),Object(b.b)("p",null,"15",".","  int\nTime step ","[0 = Prog chosen, 1 = On, 2 = Off, 3 = Arc-Length]"),Object(b.b)("p",null,"16",".","  int\nStep chosen ","[0 = Number of SubSteps, 1 = Time Increment]"),Object(b.b)("p",null,"17",".","  int\nNumber of substep"),Object(b.b)("p",null,"18",".","  int\nMax Number of substep"),Object(b.b)("p",null,"19",".","  int\nMin Number of substep"),Object(b.b)("p",null,"20",".","  double\nTime step size"),Object(b.b)("p",null,"21",".","  double\nMin time step"),Object(b.b)("p",null,"22",".","  double\nMax time step"),Object(b.b)("p",null,"23",".","  int\nWrite result fre ","[0=write every subStep, 1=Do not write any substeps,2=Write last subStep only,3= Write every Nth Substep,4=Write N Number subStep]"),Object(b.b)("p",null,"24",".","  int\niN"),Object(b.b)("p",null,"25",".","  bool\nRun APDL"),Object(b.b)("p",null,"26",".","  bool\nWrite result DB"),Object(b.b)("p",null,"27",".","  double\nEnd frequency"),Object(b.b)("p",null,"28",".","  double\nStart frequency"),Object(b.b)("p",null,"29",".","  int\nSolution option ","[0=Full,=1=Quasi,2=Linear]"),Object(b.b)("p",null,"30",".","  double\nProperty change for reformation"),Object(b.b)("p",null,"31",".","  int\nNumber of points in fast table"),Object(b.b)("p",null,"32",".","  double\nMin temperature for fast table"),Object(b.b)("p",null,"33",".","  double\nMax temperature for fast table"),Object(b.b)("p",null,"34",".","  int\nEquation solver","[0=Program Chosen,1=Frontal solver,2=Sparse solver,3=Jacobi Conj Grad,4=JCG out-of-core,5=Precondition CG,6=PCG out-of-core,7=Algebraic M-grid,8=Inc Cholesky CG,9=Iter auto select]"),Object(b.b)("p",null,"35",".","  double\nTolerance/Level"),Object(b.b)("p",null,"36",".","  double\nMultiplier"),Object(b.b)("p",null,"37",".","  bool\nSingle Precision"),Object(b.b)("p",null,"38",".","  bool\nMemory save"),Object(b.b)("p",null,"39",".","  double\nTemperature difference"),Object(b.b)("p",null,"40",".","  double\nStart frequency"),Object(b.b)("p",null,"41",".","  double\nEnd frequency"),Object(b.b)("p",null,"42",".","  int\nSubsteps"),Object(b.b)("p",null,"43",".","  double\nAlfhad"),Object(b.b)("p",null,"44",".","  double\nBetad"),Object(b.b)("p",null,"45",".","  double\nDmprat"),Object(b.b)("p",null,"46",".","  bool\nOutput displacement"),Object(b.b)("p",null,"47",".","  bool\nOutput Strain"),Object(b.b)("p",null,"48",".","  bool\nOutput Stress"),Object(b.b)("p",null,"49",".","  int\nLoad case id"),Object(b.b)("p",null,"50",".","  int\nNrmkey Normalize mode shapes ","[0=To mass matrix, 1= To unity]"),Object(b.b)("p",null,"51",".","  int\nMode Method ","[0=Block,1=Subspace,2=Reduced]"),Object(b.b)("p",null,"52",".","  int\nExtract Num"),Object(b.b)("p",null,"53",".","  bool\nExpand mode shape"),Object(b.b)("p",null,"54",".","  int\nNo. of modes to expand"),Object(b.b)("p",null,"55",".","  bool\nUse lumped mass approx."),Object(b.b)("p",null,"56",".","  bool\nIncl prestress effects"),Object(b.b)("p",null,"57",".","  bool\nMemory save"),Object(b.b)("p",null,"58",".","  bool\nResidual Vector"),Object(b.b)("p",null,"59",".","  bool\nOutput displacement"),Object(b.b)("p",null,"60",".","  bool\nOutput Strain"),Object(b.b)("p",null,"61",".","  bool\nOutput Stress"),Object(b.b)("p",null,"62",".","  int\nNum of modes to print"),Object(b.b)("p",null,"63",".","  bool\nMemory save for steady state"),Object(b.b)("p",null,"64",".","  bool\nOutput heat flux"),Object(b.b)("p",null,"65",".","  bool\nOutput temperature"),Object(b.b)("p",null,"66",".","  bool\nPivots check"),Object(b.b)("p",null,"67",".","  bool\nsingle precision"),Object(b.b)("p",null,"68",".","  double\nMultiplier"),Object(b.b)("p",null,"69",".","  double\nTemperature difference"),Object(b.b)("p",null,"70",".","  double\nTolerance level"),Object(b.b)("p",null,"71",".","  int\nAdaptive descent ","[0 = ON if necessary, 1 = ON, 2 = OFF]"),Object(b.b)("p",null,"72",".","  int\nEquation solver ","[0= Program Chosen,1= Frontal solver]"),Object(b.b)("p",null,"73",".","  int\nNewton-Raphson option","[0= Program chosen, 1= Full N-R, 2= Modified N-R, 3= Initial stiffnes, 4= Full N-R unsymm]"),Object(b.b)("p",null,"74",".","  Cstring\nAnsys version"),Object(b.b)("p",null,"75",".","  Cstring\nCommand line option"),Object(b.b)("p",null,"76",".","  bool\nOutput solver"),Object(b.b)("p",null,"77",".","  int\nRigid mode"),Object(b.b)("p",null,"78",".","  int\nWork size"),Object(b.b)("p",null,"79",".","  int\nNo of extra vectors"),Object(b.b)("p",null,"80",".","  int\nNPERBK No of modes/memory block"),Object(b.b)("p",null,"81",".","  int\nNUMSSI Maximum number of iterations"),Object(b.b)("p",null,"82",".","  int\nNSHIFT Min, before shift"),Object(b.b)("p",null,"83",".","  int\nStrmck Sturm sequence check ","[0 =At shift+end pts, 1= At shift pts, 2 = No Sturm check]"),Object(b.b)("p",null,"84",".","  bool\nTransient effects"),Object(b.b)("p",null,"85",".","  int\nLoading type ","[0= Stepped Loading,1= Ramped Loading]"),Object(b.b)("p",null,"86",".","  double\nMass matrix multiplier"),Object(b.b)("p",null,"87",".","  double\nStiffness matrix multiplier"),Object(b.b)("p",null,"88",".","  bool\nMidStep Criterion"),Object(b.b)("p",null,"89",".","  double\nTolerance for Bisection"),Object(b.b)("p",null,"90",".","  double\nTolerance for TimeStep"),Object(b.b)("p",null,"91",".","  int\nTime intergration algorithm ","[0 =Newmark,1=HHT]"),Object(b.b)("p",null,"92",".","  int\nTime intergration","[0 =Amplitude decay ,1= Integration parameters]"),Object(b.b)("p",null,"93",".","  double\nGamma"),Object(b.b)("p",null,"94",".","  double\nAlpha"),Object(b.b)("p",null,"95",".","  double\nDelta"),Object(b.b)("p",null,"96",".","  double\nAlphaF"),Object(b.b)("p",null,"97",".","  double\nAlphaM"),Object(b.b)("p",null,"98",".","  bool\nOutput temperature"),Object(b.b)("p",null,"99",".","  bool\nOutput heat flux"),Object(b.b)("p",null,"100",".","  Cursor\nEdit job"),Object(b.b)("h2",{id:"return-code"},"Return Code"),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"1")," - The function is executed correctly."),Object(b.b)("p",null,Object(b.b)("strong",{parentName:"p"},"0")," - Cannot execute."),Object(b.b)("h2",{id:"sample-code"},"Sample Code"),Object(b.b)("pre",null,Object(b.b)("code",Object(l.a)({parentName:"pre"},{className:"language-python"}),'CreateAnsysJob("Ansys", 2, 5, "Nastran4", "", 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1.79769e+308, 1.79769e+308, 0, 0.05, 64, 0, 0, 0, 0, 0, 0, 0, 1.1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, "", "", 0, 0, 8, 4, 5, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0.005, 0.252506, 0.505, 0.005, 0, 0, 0, 0:0)\n')))}a.isMDXComponent=!0}}]);